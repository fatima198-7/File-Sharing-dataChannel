<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>WebRTC File Share Fixed</title>
  </head>
  <body>
    <h3>WebRTC File Share (Fixed)</h3>

    <input type="file" id="fileInput" />
    <button id="sendFile">Send File</button>
    <br /><br />

    <button id="createOffer">Create Offer</button>
    <button id="createAnswer">Create Answer</button>
    <button id="addAnswer">Add Answer</button>

    <textarea id="offer" style="width: 100%; height: 100px"></textarea>
    <textarea id="answer" style="width: 100%; height: 100px"></textarea>

    <a id="downloadLink" href="#" download style="display: none"
      >Download File</a
    >

    <script>
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });

      let dataChannel;
      let receivedBuffers = [];
      let fileMeta = null;

      pc.onconnectionstatechange = () =>
        console.log("Connection state:", pc.connectionState);
      pc.oniceconnectionstatechange = () =>
        console.log("ICE state:", pc.iceConnectionState);

      // ðŸ”¹ Set up a data channel
      function setupChannel(ch) {
        ch.binaryType = "arraybuffer";
        ch.onopen = () => console.log("Channel open!");
        ch.onmessage = (event) => {
          if (typeof event.data === "string") {
            try {
              const meta = JSON.parse(event.data);
              if (meta.fileName) {
                fileMeta = meta;
                console.log("Receiving file:", meta.fileName);
              }
              if (meta.EOF) {
                const blob = new Blob(receivedBuffers, {
                  type: fileMeta?.type || "application/octet-stream",
                });
                const url = URL.createObjectURL(blob);
                const link = document.getElementById("downloadLink");
                link.href = url;
                link.download = fileMeta?.fileName || "received_file";
                link.style.display = "block";
                console.log("File received:", blob.size, "bytes");
                receivedBuffers = [];
              }
            } catch {
              console.log("Unknown text message:", event.data);
            }
          } else {
            receivedBuffers.push(event.data);
          }
        };
      }

      document.getElementById("createOffer").onclick = async () => {
        dataChannel = pc.createDataChannel("file");
        setupChannel(dataChannel);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await new Promise(
          (r) =>
            (pc.onicegatheringstatechange = () =>
              pc.iceGatheringState === "complete" && r())
        );
        document.getElementById("offer").value = JSON.stringify(
          pc.localDescription
        );
        console.log("Offer ready!");
      };

      document.getElementById("createAnswer").onclick = async () => {
        pc.ondatachannel = (e) => setupChannel(e.channel);
        const offer = JSON.parse(document.getElementById("offer").value);
        await pc.setRemoteDescription(offer);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await new Promise(
          (r) =>
            (pc.onicegatheringstatechange = () =>
              pc.iceGatheringState === "complete" && r())
        );
        document.getElementById("answer").value = JSON.stringify(
          pc.localDescription
        );
        console.log("Answer ready!");
      };

      document.getElementById("addAnswer").onclick = async () => {
        const answer = JSON.parse(document.getElementById("answer").value);
        if (!pc.currentRemoteDescription) {
          await pc.setRemoteDescription(answer);
          console.log("Answer added!");
        }
      };

      // Send file with metadata
      document.getElementById("sendFile").onclick = () => {
        const f = document.getElementById("fileInput").files[0];
        if (!f || !dataChannel || dataChannel.readyState !== "open") {
          alert("Channel not ready!");
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const buf = e.target.result;
          dataChannel.send(
            JSON.stringify({ fileName: f.name, type: f.type, size: f.size })
          );

          console.log("Sending file:", f.name, f.size, "bytes");

          for (let i = 0; i < buf.byteLength; i += 16384) {
            dataChannel.send(buf.slice(i, i + 16384));
          }

          setTimeout(
            () => dataChannel.send(JSON.stringify({ EOF: true })),
            300
          );
        };
        reader.readAsArrayBuffer(f);
      };
    </script>
  </body>
</html>
